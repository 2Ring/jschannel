<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title> JSChannel Tests </title>

<script type="text/javascript" src="doctestjs/doctest.js"></script>
<script type="text/javascript" src="json2.js"></script>
<script type="text/javascript" src="../src/jschannel.js"></script>
<script type="text/javascript" src="jquery.min.js"></script>
<script>
function loadChildCodeSnippets() {
  var child = $("#childId").get(0);
  $(".child-code-snippet").each(function() {
    var script = child.contentDocument.getElementById(this.id);
    if (script) {
      $(this).append('<div>This test depends on the following code, ' +
                     'defined in the child frame.</div>');
      $(this).append($('<code></code>').text(script.textContent));
    }
  });
}

$(window).load(loadChildCodeSnippets);

var intervalID = setInterval(function() {
  var failed = $('#doctestOutput span.failed');
  if (failed.text().length) {
    $('#please-wait').fadeOut(function() {
      if (failed.text() == '0')
        $("#all-tests-passed").fadeIn();
      else 
        $("#some-tests-failed, #doctestOutput").fadeIn();
    });
  }
}, 50);
</script>
<style type="text/css">
@import url('doctestjs/doctest.css');

html, body {
    font-family: "Helvetica Neue", Helvetica, Arial, FreeSans, sans-serif;
}

#all-tests-passed, #some-tests-failed {
  font-weight: bold;
  display: none;
}

#all-tests-passed {
  color: green;
}

#some-tests-failed {
  color: red;
}

#doctestOutput {
  display: none;
}

div.parent-code-snippet {
  border: 1px dotted gray;
  padding: 1em;
}

div.child-code-snippet {
  background: #e0e0e0;
  padding: 1em;
}
div.parent-code-snippet script, div.child-code-snippet code {
  display: block;
  font-family: monospace;
  white-space: pre-wrap;
}
#container {
  margin: 0 auto;
  width: 40em;
}
h1 {
  font-size: 3.8em;
  margin-bottom: 3px;
}
h1 .small {
  font-size: 0.4em;
}
h1 a {
  text-decoration: none;
}
h2 { 
  font-size: 1.5em;
}
h3 {
  text-align: center;
}
.description {
  font-size: 1.2em;
  margin-bottom: 30px;
  margin-top: 30px;
  font-style: italic;
}
.download { 
  float: right;
}
pre {
  color: gray;
  padding: 15px;
  white-space: pre-wrap;
}
hr {
  border: 0;
  width: 80%;
  border-bottom: 1px solid #aaa;
}
.footer {
  text-align:center;
  padding-top:30px;
  font-style: italic;
}

span.doctest-example-prompt {
  color: gray;
}

span.doctest-example-output {
  color: gray;
}

span.doctest-example-code-line {
  color: black;
}

pre.doctest {
  border-left: none;
}
</style>

</head>
<body>
<iframe style="display: none;" id="childId" src="index_child.html"></iframe>
<iframe style="display: none;" id="fakeChildId"></iframe>
<div id="container">
<h1> JSChannel testing </h1>

<p>
This page uses
the <a href="http://ianb.github.com/doctestjs/">doctestjs</a> library
by Ian Bicking.
</p>

<p id="please-wait">Verifying the correctness of the code on this page... <img src="ajax-loader.gif"></p>

<div id="all-tests-passed">All the code on this page is correct.</div>
<div id="some-tests-failed">Some code on this page doesn't work.</div>
<pre id="doctestOutput"></pre>

<h2>Testing constructor invocation</h2>

Test passing a bogus first parameter to <code>.build()</code>
<pre class="doctest">
$ Channel.build();
Error: Channel build invoked without a proper object argument
$ Channel.build({});
Error: Channel.build() called without a valid window argument
$ Channel.build({window: document.getElementById("fakeChildId")});
Error: Channel.build() called without a valid window argument
</pre>

Now how about the <tt>origin</tt> parameter:
<pre class="doctest">
$ tgtwin = document.getElementById("fakeChildId").contentWindow;
$ Channel.build({window: tgtwin, origin: "this isn't a valid origin!"});
Error: Channel.build() called with an invalid origin
$ Channel.build({window: tgtwin, origin: "http://trickyco.de"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de:8080"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de:8080/"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://localhost"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://localhost:1234"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://10.0.1.104:1234"}).destroy();
</pre>

And the <tt>scope</tt> parameter...

<pre class="doctest">
$ var tgtwin = document.getElementById("fakeChildId").contentWindow;
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "goodScope"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "speshulScope!@#%^@**(#(%*<>';][,.';'"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "closeTo:BadScope"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "closer:T:o:B:a:dScope"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "veryBad::Scope"});
Error: scope may not contain double colons: '::'
</pre>

<h2>query/response</h2>

<div class="parent-code-snippet">
<div>Following tests depend on this code, defined in the parent frame.</div>
<script>
// A simple function to print out any arguments passed to it.
function emit() {
    var f = 'Spy("out").func(';
    for (var i = 0; i < arguments.length; i++) {
        f += "arguments["+i+"]";
        if (i < arguments.length -1) f += ",";
    }
    f += ");";
    eval(f);
}

function wait() {
  Spy('out').wait();
}

// Allocate a single global channel that we'll run all our tests in.
var chan = Channel.build({
    window: document.getElementById("childId").contentWindow,
    origin: "*",
    scope: "testScope",
    onReady: function() {
      doctest();
    }
});
</script>
</div>

<p>Test basic query/response:</p>

<div class="child-code-snippet" id="basic-query-response"></div>

<pre class="doctest">
$ chan.call({ method: "reverse",
>             params: "hello world!",
>             success: function(v) { emit(v.toString()); } });
> wait();
out("!dlrow olleh")
</pre>

<p>Test all flavors of error responses</p>

<div class="child-code-snippet" id="error-responses"></div>

<pre class="doctest">
$ chan.call({method: "error",
>            error: emit,
>            success: emit});
> wait();
out("parameter_required", "you're missing the 'type of error to emit' parameter, doofus")
$ chan.call({method: "error",
>            params: "throw_array",
>            error: emit,
>            success: emit});
> wait();
out("array_error_code", "array error message")
$ chan.call({method: "error",
>            params: "throw_object",
>            error: emit,
>            success: emit});
> wait();
out("object_error_code", "object error message")
$ chan.call({method: "error",
>            params: "throw_string",
>            error: emit,
>            success: emit});
> wait();
out("runtime_error", "this is a string")
$ chan.call({method: "error",
>            params: "accidental_throw",
>            error: emit, 
>            success: emit});
> wait(); // exception content varies by browser
out("runtime_error", ...)
$ chan.call({method: "error",
>            params: "smush_object",
>            error: emit,
>            success: emit});
> wait(); // thrown objects get smushed.
out("runtime_error", "{\"dont\":\"smush\",\"me\":\"no!!\"...}")
$ chan.call({method: "error",
>            params: "tostring_craziness",
>            error: emit,
>            success: emit});
> wait(); // if JSON.stringify pukes, toString()
out("runtime_error", "[object ...]")
</pre>

<h2>callbacks</h2>

<div class="child-code-snippet" id="callbacks"></div>

<pre class="doctest">
$ chan.call({method: "caller_backer",
>            params: { cb: emit },
>            success: emit});
> wait();
out("you called?")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { cb2: emit },
>            success: emit});
> wait();
out("you called again!?")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { nested: { cb: emit } },
>            success: emit});
> wait();
out("STOP CALLING ME!")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { cb: emit, cb2: emit, nested: { cb: emit } }, 
>            error: emit,
>            success: emit});
> wait();
out("you called?")
out("you called again!?")
out("STOP CALLING ME!")
out("complete")
</pre>

<h2>echo test</h2>

<div class="child-code-snippet" id="echo"></div>

<pre class="doctest">
$ chan.call({method: "echo",
>            params: 0,
>            success: emit,
>            error: emit});
> wait();
out(0)
$ chan.call({method: "echo",
>            params: null,
>            success: emit,
>            error: emit});
> wait();
out(null)
$ chan.call({method: "echo",
>            params: false,
>            success: emit,
>            error: emit});
> wait();
out(false)
</pre>

<h2>timeout test</h2>

<p>Here's a trivial use of the <code>timeout</code> option.</p>

<pre class="doctest">
$ chan.call({ method: "nonexistent",
>             timeout: 50,
>             error: emit,
>             success: emit });
> wait();
out("timeout_error", "timeout (50ms) exceeded on method 'testScope::nonexistent'")
</pre>

<p>Of course, the timeout doesn't get triggered if the method call actually completes...</p>

<pre class="doctest">
$ var x = [];
> chan.call({ method: "echo",
>             params: "echo called",
>             timeout: 100,
>             error: function(e, m) { x.push(e); },
>             success: function(m) { x.push(m); }});
> setTimeout(function() { emit.apply(null, x); }, 250);
> wait();
out("echo called")
</pre>


</div>
</body>
</html>
