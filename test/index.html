<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>JSChannel Documentation</title>

<script type="text/javascript" src="doctestjs/doctest.js"></script>
<script type="text/javascript" src="json2.js"></script>
<script type="text/javascript" src="../src/jschannel.js"></script>
<script type="text/javascript" src="jquery.min.js"></script>
<script>
function loadChildCodeSnippets() {
  var child = $("#childId").get(0);
  $(".child-code-snippet").each(function() {
    var script = child.contentDocument.getElementById(this.id);
    if (script) {
      var code = jQuery.trim(script.textContent);
      $(this).append($('<code></code>').text(code));
    }
  });
}

$(window).load(loadChildCodeSnippets);

var intervalID = setInterval(function() {
  var failed = $('#doctestOutput span.failed');
  if (failed.text().length) {
    $('#please-wait').fadeOut(function() {
      if (failed.text() == '0')
        $("#all-tests-passed").fadeIn();
      else 
        $("#some-tests-failed, #doctestOutput").fadeIn();
    });
  }
}, 50);

// A simple function to print out any arguments passed to it.
function emit() {
    var f = 'Spy("out").func(';
    for (var i = 0; i < arguments.length; i++) {
        f += "arguments["+i+"]";
        if (i < arguments.length -1) f += ",";
    }
    f += ");";
    eval(f);
}

function wait() {
  Spy('out').wait();
}

$(window).load(function() { doctest(); });
</script>
<style type="text/css">
@import url('doctestjs/doctest.css');

html, body {
    font-family: "Helvetica Neue", Helvetica, Arial, FreeSans, sans-serif;
}

#all-tests-passed, #some-tests-failed {
  font-weight: bold;
  display: none;
}

#all-tests-passed {
  color: green;
}

#some-tests-failed {
  color: red;
}

#doctestOutput {
  display: none;
}

div.child-code-snippet {
  background: #e0e0e0;
  padding: 1em;
}

div.child-code-snippet code {
  display: block;
  font-family: monospace;
  white-space: pre-wrap;
}

#container {
  margin: 0 auto;
  width: 40em;
}

h1 {
  font-size: 24pt;
  margin-bottom: 3px;
}

h1 a {
  text-decoration: none;
}

h2 { 
  font-size: 18pt;
}

h3 {
  text-align: center;
}

pre {
  color: gray;
  padding: 15px;
  white-space: pre-wrap;
}

span.doctest-example-prompt {
  color: gray;
}

span.doctest-example-output {
  color: gray;
}

span.doctest-example-code-line {
  color: black;
}

pre.doctest {
  border-left: none;
}
</style>

</head>
<body>
<iframe style="display: none;" id="childId" src="index_child.html"></iframe>
<iframe style="display: none;" id="fakeChildId"></iframe>
<div id="container">
<h1>JSChannel Documentation</h1>

<p id="please-wait">Verifying the correctness of the code on this page... <img src="ajax-loader.gif"></p>

<p id="all-tests-passed">All the code on this page is correct.</p>
<p id="some-tests-failed">Some code on this page doesn't work.</p>
<pre id="doctestOutput"></pre>

<h2>About The Code Examples</h2>

<p>This page uses
the <a href="http://ianb.github.com/doctestjs/">doctestjs</a> library
by Ian Bicking. The code examples are actually run on your browser to verify their correctness.</p>

<p>All the code examples in this documentation assume communication between a parent page and a child iframe. Example code executed in the child iframe looks like this:</p>

<div class="child-code-snippet" id="sample-child-code"></div>

<p>The examples also assume that a few global functions exist in the parent page:</p>

<ul>
  <li><code>emit()</code> simply prints out its arguments, like so:

<pre class="doctest">
$ emit("hi", "there");
out("hi", "there")
</pre></li>
</ul>

<h2>Method Invocation</h2>

<p>Let's create a channel in our child frame:</p>

<div class="child-code-snippet" id="build-channel"></div>

<p>And now we'll build one in our parent page to communicate with it:</p>

<pre class="doctest">
$ var chan = Channel.build({
>   window: document.getElementById("childId").contentWindow,
>   origin: "*",
>   scope: "testScope",
>   onReady: function() {
>     emit("channel is ready!");
>   }
> });
> wait();
out("channel is ready!")
</pre>

<p>Note that the <code>onReady</code> callback is called once actual communication has been established between the parent page and child frame. If the child frame hadn't set up its end of the channel, for instance, <code>onReady</code> would never get called.</p>

<p>Now we'll define a simple function in our child frame:</p>

<div class="child-code-snippet" id="basic-query-response"></div>

<p>And call it in our parent frame.</p>

<pre class="doctest">
$ chan.call({ method: "reverse",
>             params: "hello world!",
>             success: function(v) { emit(v.toString()); } });
> wait();
out("!dlrow olleh")
</pre>

<p>Remote methods can throw errors, too. Here's one in our child frame:</p>

<div class="child-code-snippet" id="throw-object"></div>

<p>Calling that produces this:</p>

<pre class="doctest">
$ chan.call({method: "throwObject",
>            error: emit,
>            success: emit});
> wait();
out("object_error_code", "object error message")
</pre>

<p>But objects with keys other than <code>error</code> and <code>message</code>...</p>

<div class="child-code-snippet" id="throw-smushed-object"></div>

<p>...get smushed into strings by attempting to serialize them to JSON.</p>

<pre class="doctest">
$ chan.call({method: "throwSmushedObject",
>            error: emit,
>            success: emit});
> wait();
out("runtime_error", "{\"dont\":\"smush\",\"me\":\"no!!\"...}")
</pre>

<p>But objects that can't be serialized to JSON just get coerced to strings:</p>

<div class="child-code-snippet" id="throw-tostringed-object"></div>

<pre class="doctest">
$ chan.call({method: "throwToStringedObject",
>            error: emit,
>            success: emit});
> wait();
out("runtime_error", "[object ...]")
</pre>

<p>You can throw arrays, too:</p>

<div class="child-code-snippet" id="throw-array"></div>

<pre class="doctest">
$ chan.call({method: "throwArray",
>            error: emit,
>            success: emit});
> wait();
out("array_error_code", "array error message")
</pre>

<p>And strings...</p>

<div class="child-code-snippet" id="throw-string"></div>

<pre class="doctest">
$ chan.call({method: "throwString",
>            error: emit,
>            success: emit});
> wait();
out("runtime_error", "this is a string")
</pre>

<p>Totally unintentional exceptions get propagated, too:</p>

<div class="child-code-snippet" id="accidental-throw"></div>

<pre class="doctest">
$ chan.call({method: "accidentalThrow",
>            error: emit,
>            success: emit});
> wait(); // exception content varies by browser
out("runtime_error", ...)
</pre>

<p>If your method's implementation is asychronous, you can use a transaction's <code>error()</code> method to propagate errors, too.</p>

<div class="child-code-snippet" id="get-stuff"></div>

<pre class="doctest">
$ chan.call({method: "getStuff",
>            error: emit,
>            success: emit});
> wait();
out("mega_fail", "i could not get your stuff.")
</pre>

<h2>Callbacks</h2>

<p>Clients can pass functions as parameters to remote methods, and they can be called by the implementer.</p>

<div class="child-code-snippet" id="callbacks"></div>

<pre class="doctest">
$ chan.call({method: "caller_backer",
>            params: { cb: emit },
>            success: emit});
> wait();
out("you called?")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { cb2: emit },
>            success: emit});
> wait();
out("you called again!?")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { nested: { cb: emit } },
>            success: emit});
> wait();
out("STOP CALLING ME!")
out("complete")
$ chan.call({method: "caller_backer",
>            params: { cb: emit, cb2: emit, nested: { cb: emit } }, 
>            error: emit,
>            success: emit});
> wait();
out("you called?")
out("you called again!?")
out("STOP CALLING ME!")
out("complete")
</pre>

<h2>Return Types</h2>

<p>Assuming a trivial echo function like this:</p>

<div class="child-code-snippet" id="echo"></div>

<p>It's possible for a remote method to return any native JavaScript types, like numbers:</p>

<pre class="doctest">
$ chan.call({method: "echo",
>            params: 0,
>            success: emit,
>            error: emit});
> wait();
out(0)
</pre>

<p><code>null</code> works, too:</p>

<pre class="doctest">
$ chan.call({method: "echo",
>            params: null,
>            success: emit,
>            error: emit});
> wait();
out(null)
</pre>

<p>As do booleans:</p>

<pre class="doctest">
$ chan.call({method: "echo",
>            params: false,
>            success: emit,
>            error: emit});
> wait();
out(false)
</pre>

<h2>Timeouts</h2>

<p>Clients can also be notified if a remote method invocation takes too long to complete by passing a <code>timeout</code> parameter to a channel's <code>call()</code> method.</p>

<p>For instance, we can try calling a nonexistent method with a timeout:</p>

<pre class="doctest">
$ chan.call({ method: "nonexistent",
>             timeout: 50,
>             error: emit,
>             success: emit });
> wait();
out("timeout_error", "timeout (50ms) exceeded on method 'testScope::nonexistent'")
</pre>

<p>Of course, the timeout doesn't get triggered if the method call actually completes...</p>

<pre class="doctest">
$ var x = [];
> chan.call({ method: "echo",
>             params: "echo called",
>             timeout: 100,
>             error: function(e, m) { x.push(e); },
>             success: function(m) { x.push(m); }});
> setTimeout(function() { emit.apply(null, x); }, 250);
> wait();
out("echo called")
</pre>

<h2>Constructor Invocation</h2>

If you pass a bogus first parameter to <code>Channel.build()</code>, a friendly exception is thrown.

<pre class="doctest">
$ Channel.build();
Error: Channel build invoked without a proper object argument
$ Channel.build({});
Error: Channel.build() called without a valid window argument
$ Channel.build({window: document.getElementById("fakeChildId")});
Error: Channel.build() called without a valid window argument
</pre>

The <tt>origin</tt> parameter can take many different forms:

<pre class="doctest">
$ tgtwin = document.getElementById("fakeChildId").contentWindow;
$ Channel.build({window: tgtwin, origin: "http://trickyco.de"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de:8080"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de:8080/"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://localhost"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://localhost:1234"}).destroy();
$ Channel.build({window: tgtwin, origin: "http://10.0.1.104:1234"}).destroy();
</pre>

...except for obvious exceptions.

<pre class="doctest">
$ Channel.build({window: tgtwin, origin: "this isn't a valid origin!"});
Error: Channel.build() called with an invalid origin
</pre>

And the <tt>scope</tt> parameter can include almost any characters...

<pre class="doctest">
$ var tgtwin = document.getElementById("fakeChildId").contentWindow;
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "goodScope"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "speshulScope!@#%^@**(#(%*<>';][,.';'"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "closeTo:BadScope"}).destroy();
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "closer:T:o:B:a:dScope"}).destroy();
</pre>

Except for double colons.

<pre class="doctest">
$ Channel.build({window: tgtwin,
>                origin: "http://trickyco.de",
>                scope: "veryBad::Scope"});
Error: scope may not contain double colons: '::'
</pre>

</div>
</body>
</html>
