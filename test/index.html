<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>JSChannel Documentation</title>

<link rel="stylesheet" href="sh.css">
<script type="text/javascript" src="doctestjs/doctest.js"></script>
<script type="text/javascript" src="json2.js"></script>
<script type="text/javascript" src="sh_main.js"></script>
<script type="text/javascript" src="sh_javascript.min.js"></script>
<script type="text/javascript" src="../src/jschannel.js"></script>
<script type="text/javascript" src="jquery.min.js"></script>
<script>
// A simple function to print out any arguments passed to it.
function emit() {
    var f = 'Spy("out").func(';
    for (var i = 0; i < arguments.length; i++) {
        f += "arguments["+i+"]";
        if (i < arguments.length -1) f += ",";
    }
    f += ");";
    eval(f);
}

function wait() {
  Spy('out').wait();
}

function snippet() {
  /* This is intentionally empty; we pass functions containing
   * doctests in here so that they're not executed on page
   * load. */
}

jQuery.fn.extend({
  // Assuming the first matched element is a script tag,
  // return its inline source code.
  sourceCode: function() {
    // MSIE 8 uses the 'text' property for script elements,
    // while other browsers support standard DOM access.
    return $(this).get(0).text || $(this).text();
  },
  // Syntax highlight the set of matched elements using
  // the given language.
  syntaxHighlight: function(language) {
    this.each(function() {
      sh_highlightElement(this, sh_languages[language]);
    });
  }
});

$(window).ready(function() {
  function convertSnippetScriptsToDoctests() {
    $("script.doctest").each(function() {
      var doctestLines = [];
      var lines = $(this).sourceCode().split('\n');
      var inPrompt = false;
      jQuery.each(lines, function() {
        var expect = this.match(/^  \/\/ expect: (.*)/);
        if (expect) {
          doctestLines.push(expect[1]);
          inPrompt = false;
        } else if (this.match(/^  /)) {
          var prompt = inPrompt ? '>' : '$';
          doctestLines.push(prompt + this.slice(1));
          inPrompt = true;
        }
      });
      var pre = $('<pre class="doctest"></pre>');
      $(this).replaceWith(pre.text(doctestLines.join('\n')));
    });
  }

  function trimDoctests() {
    $("pre.doctest").each(function() {
      $(this).text(jQuery.trim($(this).text()));
    });
  }

  convertSnippetScriptsToDoctests();
  trimDoctests();
});

$(window).load(function() {
  function loadChildCodeSnippets() {
    var harnessChan = Channel.build({
      window: $("#childId").get(0).contentWindow,
      origin: "*",
      scope: "harness",
      onReady: function() {
        $(".child-code-snippet").each(function() {
          var element = this;
          harnessChan.call({
            method: "getScript",
            params: this.id,
            success: function(code) {
              code = jQuery.trim(code);
              var elem = $('<code></code>').text(code);
              elem.syntaxHighlight('javascript');
              $(element).append(elem);
            }
          });
        });
      }
    });    
  }

  function whenDoctestsFinish(cb) {
    // It doesn't seem like doctest.js can notify clients when
    // the tests are finished running, so we'll have to
    // poll for now.
    var intervalID = setInterval(function() {
      var failed = $('#doctestOutput span.failed');
      if (failed.text().length) {
        clearInterval(intervalID);
        cb(parseInt(failed.text()));
      }
    }, 50);
  }

  loadChildCodeSnippets();
  doctest();

  whenDoctestsFinish(function(numFailed) {
    if (numFailed == 0)
      $('span.doctest-example-code-line').each(function() {
        if ($(this).text() == 'wait();') {
          var prompt = $(this).prev('.doctest-example-prompt').get(0);
          var newline = prompt.previousSibling;

          // Not sure why $(newline).remove() doesn't work, so...
          newline.parentNode.removeChild(newline);

          $(this).parent().append('<div class="time-passes"><span>' +
                                  'Time passes\u2026</span></div>');
          $(this).add(prompt).remove();
        }
      });
    
    $('#please-wait').fadeOut(function() {
      if (numFailed == 0)
        $("#all-tests-passed").fadeIn();
      else 
        $("#some-tests-failed, #doctestOutput").fadeIn();
    });
  });
});
</script>
<style type="text/css">
@import url('doctestjs/doctest.css');

html, body {
    font-family: "Helvetica Neue", Helvetica, Arial, FreeSans, sans-serif;
}

a {
  color: inherit;
}

a:hover {
  background: yellow;
}

#all-tests-passed, #some-tests-failed {
  font-weight: bold;
  display: none;
}

#all-tests-passed {
  color: green;
}

#some-tests-failed {
  color: red;
}

#doctestOutput {
  display: none;
}

div.child-code-snippet {
  background: #f0f0f0;
  padding: 1em;
}

div.child-code-snippet code {
  display: block;
  white-space: pre-wrap;
}

#container {
  margin: 0 auto;
  width: 40em;
}

h1 {
  font-size: 24pt;
}

h2 { 
  font-size: 18pt;
}

pre {
  color: gray;
  white-space: pre-wrap;
}

pre, code {
  font-family: Monaco, "Lucida Console", monospace;
  font-size: 9pt;
}

span.doctest-example-prompt {
  color: gray;
}

span.doctest-example-output {
  color: gray;
}

span.doctest-example-code-line {
  color: black;
}

div.time-passes {
  font-size: 8pt;
  font-family: "Helvetica Neue", Helvetica, Arial, FreeSans, sans-serif;
  margin-top: 10px;
  margin-bottom: 10px;
}

div.time-passes span {
  border: 1px dotted gray;
  background: #f0f0f0;
  color: black;
  padding: 2px;  
}

pre.doctest {
  border-left: none;
}
</style>

</head>
<body>
<iframe style="display: none;" id="childId" src="index_child.html"></iframe>
<iframe style="display: none;" id="fakeChildId"></iframe>
<div id="container">
<h1>JSChannel Documentation</h1>

<p id="please-wait">Verifying the correctness of the code on this page... <img src="ajax-loader.gif"></p>

<p id="all-tests-passed">All the code on this page is correct.</p>
<p id="some-tests-failed">Some code on this page doesn't work.</p>
<pre id="doctestOutput"></pre>

<h2>About The Code Examples</h2>

<p>This page uses
the <a href="http://ianb.github.com/doctestjs/">doctestjs</a> library
by Ian Bicking. The code examples are actually run on your browser to verify their correctness.</p>

<p>All the code examples in this documentation assume communication between a parent page and a child iframe. Example code executed in the child iframe looks like this:</p>

<div class="child-code-snippet" id="sample-child-code"></div>

<p>The examples also assume that a few global functions exist in the parent page:</p>

<ul>
  <li><code>emit()</code> simply prints out its arguments, like so:

<script class="doctest">
snippet(function() {
  emit("hi", "there");
  // expect: out("hi", "there")
});
</script></li>
</ul>

<h2>Method Invocation</h2>

<p>Let's create a channel in our child frame:</p>

<div class="child-code-snippet" id="build-channel"></div>

<p>And now we'll build one in our parent page to communicate with it:</p>

<!-- We want to use chan in other doctests, and in order to keep the
     variable around on MSIE8, we need to force it to be a global. -->
<script class="doctest">
snippet(function() {
  chan = Channel.build({
    window: document.getElementById("childId").contentWindow,
    origin: "*",
    scope: "testScope",
    onReady: function() {
      emit("channel is ready!");
    }
  });
  wait();
  // expect: out("channel is ready!")
});
</script>

<p>Note that the <code>onReady</code> callback is called once actual communication has been established between the parent page and child frame. If the child frame hadn't set up its end of the channel, for instance, <code>onReady</code> would never get called.</p>

<p>Now we'll define a simple function in our child frame:</p>

<div class="child-code-snippet" id="basic-query-response"></div>

<p>And call it in our parent frame.</p>

<script class="doctest">
snippet(function() {
  chan.call({ method: "reverse",
              params: "hello world!",
              success: function(v) { emit(v.toString()); } });
  wait();
  // expect: out("!dlrow olleh")
});
</script>

<p>Remote methods can throw errors, too. Here's one in our child frame:</p>

<div class="child-code-snippet" id="throw-object"></div>

<p>Calling that produces this:</p>

<script class="doctest">
snippet(function() {
  chan.call({method: "throwObject",
             error: emit,
             success: emit});
  wait();
  // expect: out("object_error_code", "object error message")
});
</script>

<p>But objects with keys other than <code>error</code> and <code>message</code>...</p>

<div class="child-code-snippet" id="throw-smushed-object"></div>

<p>...get smushed into strings by attempting to serialize them to JSON.</p>

<script class="doctest">
snippet(function() {
  chan.call({method: "throwSmushedObject",
             error: emit,
             success: emit});
  wait();
  // expect: out("runtime_error", "{\"dont\":\"smush\",\"me\":\"no!!\"...}")
});
</script>

<p>But objects that can't be serialized to JSON just get coerced to strings:</p>

<div class="child-code-snippet" id="throw-tostringed-object"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "throwToStringedObject",
             error: emit,
             success: emit});
  wait();
  // expect: out("runtime_error", "[object...]")
});
</script>

<p>You can throw arrays, too:</p>

<div class="child-code-snippet" id="throw-array"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "throwArray",
             error: emit,
             success: emit});
  wait();
  // expect: out("array_error_code", "array error message")
});
</script>

<p>And strings...</p>

<div class="child-code-snippet" id="throw-string"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "throwString",
             error: emit,
             success: emit});
  wait();
  // expect: out("runtime_error", "this is a string")
});
</script>

<p>Totally unintentional exceptions get propagated, too:</p>

<div class="child-code-snippet" id="accidental-throw"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "accidentalThrow",
             error: emit,
             success: emit});
  // Note that the exception content varies by browser.
  wait();
  // expect: out("runtime_error", ...)
});
</script>

<p>If your method's implementation is asychronous, you can use a transaction's <code>error()</code> method to propagate errors, too.</p>

<div class="child-code-snippet" id="get-stuff"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "getStuff",
             error: emit,
             success: emit});
  wait();
  // expect: out("mega_fail", "i could not get your stuff.")
});
</script>

<h2>Callbacks</h2>

<p>Clients can pass functions as parameters to remote methods, and they can be called by the implementer.</p>

<div class="child-code-snippet" id="callbacks"></div>

<script class="doctest">
snippet(function() {
  chan.call({method: "caller_backer",
             params: { cb: emit },
             success: emit});
  wait();
  // expect: out("you called?")
  // expect: out("complete")
  chan.call({method: "caller_backer",
             params: { cb2: emit },
             success: emit});
  wait();
  // expect: out("you called again!?")
  // expect: out("complete")
  chan.call({method: "caller_backer",
             params: { nested: { cb: emit } },
             success: emit});
  wait();
  // expect: out("STOP CALLING ME!")
  // expect: out("complete")
  chan.call({method: "caller_backer",
             params: { cb: emit, cb2: emit, nested: { cb: emit } }, 
             error: emit,
             success: emit});
  wait();
  // expect: out("you called?")
  // expect: out("you called again!?")
  // expect: out("STOP CALLING ME!")
  // expect: out("complete")
});
</script>

<h2>Return Types</h2>

<p>Assuming a trivial echo function like this:</p>

<div class="child-code-snippet" id="echo"></div>

<p>It's possible for a remote method to return any native JavaScript types, like numbers:</p>

<script class="doctest">
snippet(function() {
  chan.call({method: "echo",
             params: 0,
             success: emit,
             error: emit});
  wait();
  // expect: out(0)
});
</script>

<p><code>null</code> works, too:</p>

<script class="doctest">
snippet(function() {
  chan.call({method: "echo",
             params: null,
             success: emit,
             error: emit});
  wait();
  // expect: out(null)
});
</script>

<p>As do booleans:</p>

<script class="doctest">
snippet(function() {
  chan.call({method: "echo",
             params: false,
             success: emit,
             error: emit});
  wait();
  // expect: out(false)
});
</script>

<h2>Timeouts</h2>

<p>Clients can also be notified if a remote method invocation takes too long to complete by passing a <code>timeout</code> parameter to a channel's <code>call()</code> method.</p>

<p>For instance, we can try calling a nonexistent method with a timeout:</p>

<script class="doctest">
snippet(function() {
  chan.call({ method: "nonexistent",
              timeout: 50,
              error: emit,
              success: emit });
  wait();
  // expect: out("timeout_error", "timeout (50ms) exceeded on method 'testScope::nonexistent'")
});
</script>

<p>Of course, the timeout doesn't get triggered if the method call actually completes...</p>

<script class="doctest">
snippet(function() {
  var x = [];
  chan.call({ method: "echo",
              params: "echo called",
              timeout: 100,
              error: function(e, m) { x.push(e); },
              success: function(m) { x.push(m); }});
  setTimeout(function() { emit.apply(null, x); }, 250);
  wait();
  // expect: out("echo called")
});
</script>

<h2>Constructor Invocation</h2>

If you pass a bogus first parameter to <code>Channel.build()</code>, a friendly exception is thrown.

<script class="doctest">
snippet(function() {
  Channel.build();
  // expect: Error: Channel build invoked without a proper object argument
  Channel.build({});
  // expect: Error: Channel.build() called without a valid window argument
  Channel.build({window: document.getElementById("fakeChildId")});
  // expect: Error: Channel.build() called without a valid window argument
});
</script>

The <tt>origin</tt> parameter can take many different forms:

<script class="doctest">
snippet(function() {
  tgtwin = document.getElementById("fakeChildId").contentWindow;
  Channel.build({window: tgtwin, origin: "http://trickyco.de"}).destroy();
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de:8080"}).destroy();
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de:8080/"}).destroy();
  Channel.build({window: tgtwin, origin: "http://localhost"}).destroy();
  Channel.build({window: tgtwin, origin: "http://localhost:1234"}).destroy();
  Channel.build({window: tgtwin, origin: "http://10.0.1.104:1234"}).destroy();
});
</script>

...except for obvious exceptions.

<script class="doctest">
snippet(function() {
  Channel.build({window: tgtwin, origin: "this isn't a valid origin!"});
  // expect: Error: Channel.build() called with an invalid origin
});
</script>

And the <tt>scope</tt> parameter can include almost any characters...

<script class="doctest">
snippet(function() {
  var tgtwin = document.getElementById("fakeChildId").contentWindow;
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de",
                 scope: "goodScope"}).destroy();
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de",
                 scope: "speshulScope!@#%^@**(#(%*<>';][,.';'"}).destroy();
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de",
                 scope: "closeTo:BadScope"}).destroy();
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de",
                 scope: "closer:T:o:B:a:dScope"}).destroy();
});
</script>

Except for double colons.

<script class="doctest">
snippet(function() {
  Channel.build({window: tgtwin,
                 origin: "http://trickyco.de",
                 scope: "veryBad::Scope"});
  // expect: Error: scope may not contain double colons: '::'
});
</script>

</div>
</body>
</html>
